<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[思]]></title>
  <subtitle><![CDATA[我的技术总结]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2016-01-07T06:58:24.834Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name><![CDATA[Oabinga]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[C++时间库（四） 总结]]></title>
    <link href="http://yoursite.com/2016/01/07/C++%E6%97%B6%E9%97%B4%E5%BA%93%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yoursite.com/2016/01/07/C++时间库（四）/</id>
    <published>2016-01-07T01:45:12.000Z</published>
    <updated>2016-01-07T06:58:24.834Z</updated>
    <content type="html"><![CDATA[<p>前面三节总结了C++开发中使用的库和函数，但是它们的特点和之间的联系是什么呢，什么情况应该选择什么样的时间库呢，现在总结一下。</p>
<a id="more"></a>
<h2 id="C_u98CE_u683C_u7684_u65F6_u95F4_u51FD_u6570"><a href="#C_u98CE_u683C_u7684_u65F6_u95F4_u51FD_u6570" class="headerlink" title="C风格的时间函数"></a>C风格的时间函数</h2><p>C库的时间函数已经被使用了几十年，它包含了时间点和时间段两个概念。</p>
<ul>
<li><code>time_t</code>表示时间点</li>
<li><code>double difftime(time_t t1, time_t t2);</code>计算时间段</li>
<li><code>time_t time(time_t*);</code>返回当前时间</li>
</ul>
<p>此外C库还包含将时间点与公历(使用<code>struct tm</code>表示)进行转换的函数。</p>
<p>时间点一个重要特征是应该能进行比较。要想比较两个时间需要一个共同的时间参考点（epoch）和相同的时间单位，而时间参考点（epoch）的信息，可以不用关心。</p>
<p>C委员会没有指定<code>time_t</code>的时间参考点（epoch）和时间单位。好处是平台可以容易的修改epoch的定义。如果一个程序需要导入或者导出另一个程序的时间点，首先要转换时间点到约定的epoch上，比如公历。</p>
<p>POSIX指定<code>time_t</code>时间单位为秒，过去几十年，<code>time_t</code>约定俗成地表示为从1970年开始的秒数，并用32位整数存储。但是这有几个问题：</p>
<ul>
<li><code>time_t</code>时间单位是秒，<code>difftime</code>计算的时间段也是秒，所以它不能处理小于1秒的情况。</li>
<li>32位的<code>time_t</code>最大只能表示到2038年1月18日19时14分07秒，否则会溢出。</li>
</ul>
<p>虽然可以使用64位的<code>time_t</code>来解决第二个问题，但第一个问题仍不能解决。<br>后来POSIX提出了<code>struct timeb</code>, <code>struct timeval</code>和<code>struct timespec</code>将精度提高到毫秒、微秒和纳秒。但是每一个精度都需要一个新接口和新的结构体。纳秒是尽头吗？不一定，这也意味着将来需要定义新的接口和结构体来满足要求。</p>
<h2 id="Chrono_u5E93"><a href="#Chrono_u5E93" class="headerlink" title="Chrono库"></a>Chrono库</h2><p>C风格的时间函数缺乏灵活性和扩展性，为了解决这个问题，Chrono库对此进行了抽象，抽象出时间段（duration）、时间点（time_point）和时钟（clock）。</p>
<ul>
<li>时间段（duration）可以有不同的时间精度，不同精度的时间段使用同样的接口。</li>
<li>时间点（time_point）表示参考时间点（epoch）加上或者减去一个时间段。它的时间参考点由时钟（clock）决定。</li>
<li>时钟（clock）提供参数时间点（epoch）和时间精度。能返回当前时间点。</li>
</ul>
<p>这种抽象，能解决上面提到的C风格的时间函数的问题，能很方便的在不同时间精度间进行转换，也可以实现新epoch的clock，在同一个clock中，time_point可以进行比较，如果知道两个clock的epoch的转换规则，两个clock中的time_point可以相互转换和比较。</p>
<p><code>system_clock</code>可以映射时间点到C风格的时间上（<code>time_t</code>），即可以与<code>time_t</code>进行相互转换。</p>
<p>此外这个库没有格式化函数，需要转换成<code>time_t</code>或者<code>tm</code>，使用C风格时间函数进行格式化。</p>
<p>顺带说一下，这里的Chrono库是指std::chrono或者Boost.Chrono库。</p>
<h2 id="Boost-Date_Time"><a href="#Boost-Date_Time" class="headerlink" title="Boost.Date_Time"></a>Boost.Date_Time</h2><p>虽然Chrono库能很好的解决时间处理问题，但是它没有比hour更高的计时单位，所以处理日期的能力不是很强，而Boost.Date_Time库关注日期和时间。它有很多用于为本地化显示而格式化日期的函数，而且有很多函数用于获取和操作日期和时间。</p>
<p>Chrono库与Date_Time库还有一个区别就是，对于Chrono，某一刻的时间更多的是用距离某一个参考时间点的偏移（例如从1970年1月1日开始）来表示，而Date_Time库具有公历日期，可以绝对表示某一个时间点，不需要相对某个参考时间点来表示。<br>这两个库可以互补，当然也有重复的地方。但是这两个库没有任何交互操作，所以不得不进行手工转换。</p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li>如果是新开发的程序需要处理时间，尽量使用std::chrono，如果需要对日期进行处理或者需要对时间进行合并、拆分和比较的需求时，最好选择Boost.Date_Time库，除了格式化外，尽量少使用C风格的时间函数。</li>
<li><code>time_t</code>可以作为这几个库进行转换的中转类型。因为这些库都提供了对它的转换函数。</li>
</ul>
<p>C++中的时间库就是这么扯淡，且不说时区转换的问题，光是这几个库中的类型来回倒腾转换，就能把程序猿绕晕了。真心希望这个系列的总结能将这些知识梳理清晰，使用时不再犯糊涂。</p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm" target="_blank" rel="external">N2661 - A Foundation to Sleep On</a></li>
<li><a href="http://stackoverflow.com/questions/6730422/boost-chrono-vs-boost-date-time" target="_blank" rel="external">Boost.Chrono vs. Boost.Date_Time</a>。</li>
</ol>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2016/01/07/C++时间库（四）/">http://yoursite.com/2016/01/07/C++时间库（四）/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面三节总结了C++开发中使用的库和函数，但是它们的特点和之间的联系是什么呢，什么情况应该选择什么样的时间库呢，现在总结一下。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++时间库（三） Boost.Date_Time库]]></title>
    <link href="http://yoursite.com/2016/01/06/C++%E6%97%B6%E9%97%B4%E5%BA%93%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yoursite.com/2016/01/06/C++时间库（三）/</id>
    <published>2016-01-06T06:21:51.000Z</published>
    <updated>2016-01-07T06:26:13.240Z</updated>
    <content type="html"><![CDATA[<p>前面两节，总结了C风格的时间函数和C++标准库std::chrono，作为C++的一个重要的开发库Boost，它提供了两个时间库Boost.Chrono和Boost.Date_Time，这里只对Boost.Date_Time库进行简单地总结和梳理，没有面面俱到，详细说明可以参考<a href="http://www.boost.org/doc/libs/master/doc/html/date_time.html" target="_blank" rel="external">Boost.Date_Time</a>。</p>
<a id="more"></a>
<h2 id="Gregorian"><a href="#Gregorian" class="headerlink" title="Gregorian"></a>Gregorian</h2><p>是一个基于公历的日期库，Boost.DateTime支持从1400年至9999年的历法日期。<br>所有gregorian类型都在<code>boost::gregorian</code>命名空间下。没有input/output依赖的类包含在<code>boost/date_time/gregorian/gregorian_types.hpp</code>中，<code>boost/date_time/gregorian/gregorian.hpp</code>包含所有类型和input/output代码。<br>主要类型：<code>date</code>、<code>date_duration</code>、<code>date_period</code>、<code>date_iterator</code></p>
<h3 id="Date"><a href="#Date" class="headerlink" title="Date"></a>Date</h3><p><code>date</code>代表了一个日期，由年、月、日组成。<br>它可以从年月日进行构造<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date(greg_year, greg_month, greg_day)</span><br></pre></td></tr></table></figure></p>
<p>从字符串构造<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">date from_string(std::string)</span><br><span class="line">date from_undelimited_string(std::string)</span><br><span class="line"></span><br><span class="line">std::string ds("2002/1/25");</span><br><span class="line">date d(from_string(ds));</span><br><span class="line"></span><br><span class="line">std::string ds("20020125");</span><br><span class="line">date d(from_undelimited_string(ds));</span><br></pre></td></tr></table></figure></p>
<p>从clock构造<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">date d(day_clock::local_day()); //Get the local day based on the time zone settings of the computer.</span><br><span class="line">date d(day_clock::universal_day()); //Get the UTC day.</span><br></pre></td></tr></table></figure></p>
<p>从结构体tm创建<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tm d_tm;</span><br><span class="line">d_tm.tm_year = <span class="number">105</span>;</span><br><span class="line">d_tm.tm_mon  = <span class="number">0</span>;</span><br><span class="line">d_tm.tm_mday = <span class="number">1</span>;</span><br><span class="line">date d = date_from_tm(d_tm);</span><br><span class="line"><span class="comment">// d =&gt; 2005-Jan-01</span></span><br></pre></td></tr></table></figure></p>
<p>可以转换成字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string to_simple_string(date d) //"2002-Jan-01"</span><br><span class="line">std::string to_iso_string(date d) //"20020131"</span><br><span class="line">std::string to_iso_extended_string(date d) //"2002-01-31"</span><br></pre></td></tr></table></figure></p>
<p>可以转换成结构体tm<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">date <span class="title">d</span><span class="params">(<span class="number">2005</span>,Jan,<span class="number">1</span>)</span></span>;</span><br><span class="line">tm d_tm = to_tm(d);</span><br><span class="line"><span class="comment">/* tm_year =&gt; 105</span><br><span class="line">   tm_mon  =&gt; 0</span><br><span class="line">   tm_mday =&gt; 1</span><br><span class="line">   tm_wday =&gt; 6 (Saturday)</span><br><span class="line">   tm_yday =&gt; 0</span><br><span class="line">   tm_hour =&gt; 0</span><br><span class="line">   tm_min  =&gt; 0</span><br><span class="line">   tm_sec  =&gt; 0</span><br><span class="line">   tm_isddst =&gt; -1 */</span></span><br></pre></td></tr></table></figure></p>
<p>能进行加减算术运算和逻辑运算。</p>
<h3 id="Date_Duration"><a href="#Date_Duration" class="headerlink" title="Date Duration"></a>Date Duration</h3><p><code>boost::gregorian::date_duration</code>表示时间长度，被用做的<code>gregorian::date</code>的算术运算，可正可负。<br><code>boost::gregorian::date_duration</code>被<code>typedef</code>成<code>days</code>。<br>这里还包括其它duration类型：<code>months</code>，<code>years</code>，<code>weeks</code>。</p>
<h3 id="Date_Period"><a href="#Date_Period" class="headerlink" title="Date Period"></a>Date Period</h3><p><code>boost::gregorian::date_period</code>表示两个日期之间的区间。利用它可以检测某个日期是否在某个假日或者周末内，可以计算一个时间区间与另一个时间区间的交集或者并集等。<br>可以用两个日期或者一个日期和一个时间长度进行构造:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">date_period dp(date(2002,Jan,10),</span><br><span class="line">               date(2002,Jan,12));</span><br><span class="line">date_period dp(date(2002,Jan,10),</span><br><span class="line">               days(2));</span><br></pre></td></tr></table></figure></p>
<h2 id="Posix_Time"><a href="#Posix_Time" class="headerlink" title="Posix Time"></a>Posix Time</h2><p>定义了一个非调节的时间系统，这个系统具有纳秒/毫秒精度和稳定计算的特性。对于<code>ptime</code>，纳秒精度下使用96 bits存储，毫秒精度下使用64 bits存储。这个时间系统使用公历（Gregrorian calendar)去表示时间中的日期部分。</p>
<h3 id="Ptime"><a href="#Ptime" class="headerlink" title="Ptime"></a>Ptime</h3><p><code>boost::posix_time::ptime</code>表示一个与时区无关的时间点，日期部分依赖于<code>gregorian::date</code>。<br><strong>注意</strong>：<br><strong>此时间点与时区无关</strong>，例如：<br><code>ptime t(second_clock::local_time());</code><br>此时的时间t是本地时间。<br><code>ptime t(second_clock::universal_time());</code><br>而此时的时间t是UTC时间。</p>
<p>使用日期加时间偏移构造：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ptime t1(date(2002,Jan,10),</span><br><span class="line">         time_duration(1,2,3));</span><br><span class="line">ptime t2(date(2002,Jan,10),</span><br><span class="line">         hours(1)+nanosec(5));</span><br></pre></td></tr></table></figure></p>
<p>从字符串创建：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string ts("2002-01-20 23:59:59.000");</span><br><span class="line">ptime t(time_from_string(ts))</span><br><span class="line"></span><br><span class="line">std::string ts("20020131T235959");</span><br><span class="line">ptime t(from_iso_string(ts))</span><br></pre></td></tr></table></figure></p>
<p>从时钟构造：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptime t(second_clock::local_time()); //本地时间</span><br><span class="line"></span><br><span class="line">ptime t(second_clock::universal_time()) //UTC时间</span><br><span class="line"></span><br><span class="line">ptime t(microsec_clock::local_time());</span><br><span class="line"></span><br><span class="line">ptime t(microsec_clock::universal_time());</span><br></pre></td></tr></table></figure></p>
<p>使用转换函数创建：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//time_t -&gt; ptime</span></span><br><span class="line"><span class="function">ptime <span class="title">from_time_t</span><span class="params">(time_t t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FILETIEM -&gt; ptime</span></span><br><span class="line">ptime from_ftime&lt;ptime&gt;(FILETIME ft);</span><br><span class="line"></span><br><span class="line"><span class="comment">//tm -&gt; ptime</span></span><br><span class="line"><span class="function">ptime <span class="title">ptime_from_tm</span><span class="params">(tm timetm)</span></span><br><span class="line"></span><br><span class="line">tm pt_tm</span>;</span><br><span class="line">pt_tm.tm_year = <span class="number">105</span>;</span><br><span class="line">pt_tm.tm_mon  = <span class="number">0</span>;</span><br><span class="line">pt_tm.tm_mday = <span class="number">1</span>;</span><br><span class="line">pt_tm.tm_hour = <span class="number">1</span>;</span><br><span class="line">pt_tm.tm_min  = <span class="number">2</span>;</span><br><span class="line">pt_tm.tm_sec  = <span class="number">3</span>;</span><br><span class="line">ptime pt = ptime_from_tm(pt_tm);</span><br><span class="line"><span class="comment">// pt =&gt; 2005-Jan-01 01:02:03</span></span><br></pre></td></tr></table></figure></p>
<p>转换成字符串<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string to_simple_string(ptime) //2002-Jan-01 10:00:01.123456789</span><br><span class="line"></span><br><span class="line">std::string to_iso_string(ptime)  //20020131T100001,123456789</span><br><span class="line"></span><br><span class="line">std::string to_iso_extended_string(ptime) //2002-01-31T10:00:01,123456789</span><br></pre></td></tr></table></figure></p>
<p>转换成结构体tm<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ptime pt(date(2005,Jan,1), time_duration(1,2,3));</span><br><span class="line">tm pt_tm = to_tm(pt);</span><br><span class="line">/* tm_year =&gt; 105</span><br><span class="line">   tm_mon  =&gt; 0</span><br><span class="line">   tm_mday =&gt; 1</span><br><span class="line">   tm_wday =&gt; 6 (Saturday)</span><br><span class="line">   tm_yday =&gt; 0</span><br><span class="line">   tm_hour =&gt; 1</span><br><span class="line">   tm_min  =&gt; 2</span><br><span class="line">   tm_sec  =&gt; 3</span><br><span class="line">   tm_isddst =&gt; -1 */</span><br></pre></td></tr></table></figure></p>
<h3 id="Time_Duration"><a href="#Time_Duration" class="headerlink" title="Time Duration"></a>Time Duration</h3><p><code>boost::posix_time::time_duration</code>代表时间长度，可正可负。<br>下面展示了几个继承自<code>time_duration</code>的辅助类：<br><img src="/images/time_duration_inherit.png" alt="time_duration_inherit"><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost::posix_time;</span><br><span class="line"></span><br><span class="line">time_duration td = hours(<span class="number">1</span>) + seconds(<span class="number">10</span>); <span class="comment">//01:00:10</span></span><br><span class="line">td = hours(<span class="number">1</span>) + nanoseconds(<span class="number">5</span>); <span class="comment">//01:00:00.000000005</span></span><br></pre></td></tr></table></figure></p>
<p>构造函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time_duration(hours,</span><br><span class="line">              minutes,</span><br><span class="line">              seconds,</span><br><span class="line">              fractional_seconds)</span><br></pre></td></tr></table></figure></p>
<p>可以使用<code>hours</code>,<code>minutes</code>,<code>seconds</code>,<code>milliseconds</code>,<code>microseconds</code>,<code>nanoseconds</code>来构造：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time_duration td = hours(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">time_duration td = milliseconds(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>还记得上一节在std::chrono命名空间下也有<code>hours</code>,<code>minutes</code>,<code>seconds</code>,<code>milliseconds</code>,<code>microseconds</code>,<code>nanoseconds</code>这些类型，不要混了。</p>
<p>从字符串创建：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::string ts("23:59:59.000");</span><br><span class="line">time_duration td(duration_from_string(ts));</span><br></pre></td></tr></table></figure></p>
<p>转换成结构体tm：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">time_duration <span class="title">td</span><span class="params">(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">tm td_tm = to_tm(td);</span><br><span class="line"><span class="comment">/* tm_year =&gt; 0</span><br><span class="line">   tm_mon  =&gt; 0</span><br><span class="line">   tm_mday =&gt; 0</span><br><span class="line">   tm_wday =&gt; 0</span><br><span class="line">   tm_yday =&gt; 0</span><br><span class="line">   tm_hour =&gt; 1</span><br><span class="line">   tm_min  =&gt; 2</span><br><span class="line">   tm_sec  =&gt; 3</span><br><span class="line">   tm_isddst =&gt; -1 */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Time_Period"><a href="#Time_Period" class="headerlink" title="Time Period"></a>Time Period</h3><p><code>boost::posix_time::time_period</code>表示两个时间的区间。类似于<code>date_period</code>。</p>
<p>用两个时间点来构造：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">date d(2002,Jan,01);</span><br><span class="line">ptime t1(d, seconds(10)); //10 sec after midnight</span><br><span class="line">ptime t2(d, hours(10)); //10 hours after midnight</span><br><span class="line">time_period tp(t1, t2); //Create a period as [begin, end). If end is &lt;= begin then the period will be defined as invalid.</span><br><span class="line"></span><br><span class="line">date d(2002,Jan,01);</span><br><span class="line">ptime t(d, seconds(10)); //10 sec after midnight</span><br><span class="line">time_period tp(t, hours(3)); //Create a period as [begin, begin+len) where end would be begin+len. If len is &lt;= zero then the period will be defined as invalid.</span><br></pre></td></tr></table></figure></p>
<h2 id="Local_Time"><a href="#Local_Time" class="headerlink" title="Local Time"></a>Local Time</h2><p>这个库包括四个主要的本地时间管理扩展。<br><code>local_date_time</code>本地时间<br><code>posix_time_zone</code>由posix字符串（”EST10EDT,M10.5.0,M3.5.0/03”）定义的时区<br><code>time_zone_database</code>从.csv文件中用区域获取时区<br><code>time_zone</code>抽象的时区接口</p>
<p>这些扩展定义了一个用于调整时间到本地时区的时间系统。这个时间系统使用了posix_time系统的所有特性和优点。<code>time_zone</code>包含用于时区转换的所有必要数据/规则。</p>
<h3 id="Time_Zone_uFF08_u62BD_u8C61_uFF09"><a href="#Time_Zone_uFF08_u62BD_u8C61_uFF09" class="headerlink" title="Time Zone（抽象）"></a>Time Zone（抽象）</h3><p><code>time_zone_base</code>是表示时区的一个抽象基类模板。<code>date_time</code>库靠<code>boost::shared_ptr&lt;time_zone_base&gt;</code>来处理时区。为了使用方便，<code>time_zone_base</code>被<code>typedef</code>成<code>time_zone</code>。</p>
<h3 id="Posix_Time_Zone"><a href="#Posix_Time_Zone" class="headerlink" title="Posix Time Zone"></a>Posix Time Zone</h3><p>一个<code>posix_time_zone</code>对象包含一个时区的数据和规则，像距离UTC时间的偏移、名称、缩写和夏令时规则。</p>
<h3 id="Time_Zone_Database"><a href="#Time_Zone_Database" class="headerlink" title="Time Zone Database"></a>Time Zone Database</h3><p>本地时间系统依赖于时区信息的存储。时区数据库就是用来存储这些数据的。</p>
<h4 id="Local_Date_Time"><a href="#Local_Date_Time" class="headerlink" title="Local Date Time"></a>Local Date Time</h4><p><code>local_date_time</code>就是一个时间点和对应的时区。时间在内部用UTC表示。</p>
<p>从clock构造：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">time_zone_ptr zone(</span><br><span class="line">  new posix_time_zone("MST-07")</span><br><span class="line">);</span><br><span class="line">local_date_time ldt =</span><br><span class="line">  local_microsec_clock::local_time(</span><br><span class="line">    zone);</span><br><span class="line"></span><br><span class="line">time_zone_ptr zone(</span><br><span class="line">  new posix_time_zone("MST-07")</span><br><span class="line">);</span><br><span class="line">local_date_time ldt =</span><br><span class="line">  local_sec_clock::local_time(zone);</span><br></pre></td></tr></table></figure></p>
<p>从ptime构造：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 3am, 2004-Nov-05 local time</span><br><span class="line">ptime pt(date(2004,Nov,5),</span><br><span class="line">         hours(10));</span><br><span class="line">time_zone_ptr zone(</span><br><span class="line">  new posix_time_zone("MST-07"));</span><br><span class="line">local_date_time az(pt, zone);</span><br></pre></td></tr></table></figure></p>
<p>转换成结构体tm：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">// 6am, 2005-Jul-05 local time</span><br><span class="line">std::string z("EST-05EDT,M4.1.0,M10.1.0");</span><br><span class="line">ptime pt(date(2005,Jul,5),</span><br><span class="line">         hours(10));</span><br><span class="line">time_zone_ptr zone( new posix_time_zone(z));</span><br><span class="line">local_date_time ldt(pt, zone);</span><br><span class="line">tm ldt_tm = to_tm(ldt);</span><br><span class="line">/* tm_year =&gt; 105</span><br><span class="line">   tm_mon  =&gt; 6</span><br><span class="line">   tm_mday =&gt; 5</span><br><span class="line">   tm_wday =&gt; 2 (Tuesday)</span><br><span class="line">   tm_yday =&gt; 185</span><br><span class="line">   tm_hour =&gt; 6</span><br><span class="line">   tm_min  =&gt; 0</span><br><span class="line">   tm_sec  =&gt; 0</span><br><span class="line">   tm_isddst =&gt; 1 */</span><br></pre></td></tr></table></figure></p>
<h3 id="Local_Time_Period"><a href="#Local_Time_Period" class="headerlink" title="Local Time Period"></a>Local Time Period</h3><p><code>boost::local_time::local_time_period</code>表示两个本地时间的区间，与<code>date_period</code>和<code>time_period</code>类似。</p>
<h2 id="Date_Time_Input/Output"><a href="#Date_Time_Input/Output" class="headerlink" title="Date Time Input/Output"></a>Date Time Input/Output</h2><p><code>IO streaming system</code>给用户提供了灵活的日期和时间展示方式。其自定义项分为两部分：格式化标识和字符串元素。格式化标识提供了日期元素和日期类型的组织顺序上的灵活性，自定义字符串元素允许替换内建的月份名称、周名称等其它IO内建的字符串。<br>输出系统基于<code>date_facet</code>（派生自<code>std::facet</code>），输入系统基于<code>date_input_facet</code>。</p>
<h3 id="IO_u5BF9_u8C61"><a href="#IO_u5BF9_u8C61" class="headerlink" title="IO对象"></a>IO对象</h3><table>
<thead>
<tr>
<th>Output</th>
<th>Input</th>
</tr>
</thead>
<tbody>
<tr>
<td>date_facet</td>
<td>date_input_facet</td>
</tr>
<tr>
<td>wdate_facet</td>
<td>wdate_input_facet</td>
</tr>
<tr>
<td>time_facet</td>
<td>time_input_facet</td>
</tr>
<tr>
<td>wtime_facet</td>
<td>wtime_input_facet</td>
</tr>
<tr>
<td>local_time_facet*</td>
<td>local_time_input_facet*</td>
</tr>
<tr>
<td>wlocal_time_facet*</td>
<td>wlocal_time_input_facet*</td>
</tr>
</tbody>
</table>
<h3 id="Formatter/Parser_u5BF9_u8C61"><a href="#Formatter/Parser_u5BF9_u8C61" class="headerlink" title="Formatter/Parser对象"></a>Formatter/Parser对象</h3><table>
<thead>
<tr>
<th>Output</th>
<th>Input</th>
</tr>
</thead>
<tbody>
<tr>
<td>period_formatter</td>
<td>period_parser</td>
</tr>
<tr>
<td>date_generator_formatter</td>
<td>date_generator_parser</td>
</tr>
<tr>
<td>special_values_formatter</td>
<td>special_values_parser</td>
</tr>
<tr>
<td>null</td>
<td>format_date_parser</td>
</tr>
</tbody>
</table>
<p>示例1：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">date <span class="title">d</span><span class="params">(<span class="number">2004</span>, Feb, <span class="number">29</span>)</span></span>;</span><br><span class="line"><span class="function">time_duration <span class="title">td</span><span class="params">(<span class="number">12</span>,<span class="number">34</span>,<span class="number">56</span>,<span class="number">789</span>)</span></span>;</span><br><span class="line"><span class="built_in">stringstream</span> ss;</span><br><span class="line">ss &lt;&lt; d &lt;&lt; <span class="string">' '</span> &lt;&lt; td;</span><br><span class="line"><span class="function">ptime <span class="title">pt</span><span class="params">(not_a_date_time)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pt &lt;&lt; endl; <span class="comment">// "not-a-date-time"</span></span><br><span class="line">ss &gt;&gt; pt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; pt &lt;&lt; endl; <span class="comment">// "2004-Feb-29 12:34:56.000789"</span></span><br><span class="line">ss.str(<span class="string">""</span>);</span><br><span class="line">ss &lt;&lt; pt &lt;&lt; <span class="string">" EDT-05EDT,M4.1.0,M10.5.0"</span>;</span><br><span class="line"><span class="function">local_date_time <span class="title">ldt</span><span class="params">(not_a_date_time)</span></span>;</span><br><span class="line">ss &gt;&gt; ldt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ldt &lt;&lt; endl; <span class="comment">// "2004-Feb-29 12:34:56.000789 EDT"</span></span><br><span class="line"></span><br><span class="line">local_time_facet* output_facet = <span class="keyword">new</span> local_time_facet();</span><br><span class="line">local_time_input_facet* input_facet = <span class="keyword">new</span> local_time_input_facet();</span><br><span class="line">ss.imbue(locale(locale::classic(), output_facet));</span><br><span class="line">ss.imbue(locale(ss.getloc(), input_facet));</span><br><span class="line"></span><br><span class="line">output_facet-&gt;format(<span class="string">"%a %b %d, %H:%M %z"</span>);</span><br><span class="line">ss.str(<span class="string">""</span>);</span><br><span class="line">ss &lt;&lt; ldt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.str() &lt;&lt; endl; <span class="comment">// "Sun Feb 29, 12:34 EDT"</span></span><br><span class="line"></span><br><span class="line">output_facet-&gt;format(local_time_facet::iso_time_format_specifier);</span><br><span class="line">ss.str(<span class="string">""</span>);</span><br><span class="line">ss &lt;&lt; ldt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.str() &lt;&lt; endl; <span class="comment">// "20040229T123456.000789-0500"</span></span><br><span class="line"></span><br><span class="line">output_facet-&gt;format(local_time_facet::iso_time_format_extended_specifier);</span><br><span class="line">ss.str(<span class="string">""</span>);</span><br><span class="line">ss &lt;&lt; ldt;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ss.str() &lt;&lt; endl; <span class="comment">// "2004-02-29 12:34:56.000789-05:00"</span></span><br></pre></td></tr></table></figure></p>
<p>示例2，这是一个格式化时间的函数，应用最多的应该是格式化time_t时间（第二个函数）。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::string FormatTime(const ptime&amp; pt, const char* time_format) &#123;</span><br><span class="line">    std::stringstream stream;</span><br><span class="line">    std::locale currlocale(std::locale::classic(),</span><br><span class="line">                                        new time_facet(time_format));</span><br><span class="line">    stream.imbue(currlocale);</span><br><span class="line">    stream &lt;&lt; pt;</span><br><span class="line">    return stream.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::string FormatLocalTime(std::time_t t, const char* time_format) &#123;</span><br><span class="line">    return FormatTime(local_adj::utc_to_local(from_time_t(t)), time_format);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>:<br><code>std::ios_base::imbue</code>就是设置本地化。<br>C++输入/输出库中的每一个stream对象都会关联一个locale对象，locale对象会使用facet去解析和格式化所有的数据。此外，每一个<code>std::basic_regxe</code>对象会关联一个locale对象。locale对象还可以用于标准容器和算法执行字符串排序时的断言。</p>
<p><strong>注意</strong>：<br><code>std::locale</code>构造函数的第二个参数facet，需要在堆中分配，如果使用局部变量（对象在栈中），会引起程序崩溃，而且最后也不要手工<code>delete</code>这个facet对象，因为<code>std::locale</code>在析构中会自动释放内存。<br>参看<a href="https://rhubbarb.wordpress.com/2009/10/17/boost-datetime-locales-and-facets/" target="_blank" rel="external">Boost DateTime, Locales and Facets</a></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><p>总的来说Boost.Date_Time库比较庞大，提供的功能非常多，使用也非常方便，但是细节比较多，这里只能简单得梳理一下，下一节将总结一下三个库。</p>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2016/01/06/C++时间库（三）/">http://yoursite.com/2016/01/06/C++时间库（三）/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前面两节，总结了C风格的时间函数和C++标准库std::chrono，作为C++的一个重要的开发库Boost，它提供了两个时间库Boost.Chrono和Boost.Date_Time，这里只对Boost.Date_Time库进行简单地总结和梳理，没有面面俱到，详细说明可以参考<a href="http://www.boost.org/doc/libs/master/doc/html/date_time.html">Boost.Date_Time</a>。</p>]]>
    
    </summary>
    
      <category term="Boost" scheme="http://yoursite.com/tags/Boost/"/>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++时间库（二） std::chrono时间库]]></title>
    <link href="http://yoursite.com/2016/01/06/C++%E6%97%B6%E9%97%B4%E5%BA%93%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2016/01/06/C++时间库（二）/</id>
    <published>2016-01-06T06:19:22.000Z</published>
    <updated>2016-01-07T05:54:25.554Z</updated>
    <content type="html"><![CDATA[<p>自从C++11之后，标准库中出现了一个std::chrono库，这个库对时间的一些感念进行抽象，在灵活性和扩展性上要好于C风格的时间函数。下面就梳理一下这个库。</p>
<a id="more"></a>
<h2 id="u6982_u8C8C"><a href="#u6982_u8C8C" class="headerlink" title="概貌"></a>概貌</h2><p>这个库源自<a href="http://www.boost.org/doc/libs/1_60_0/doc/html/chrono.html" target="_blank" rel="external">Boost.Chrono</a>，<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2661.htm" target="_blank" rel="external">N2661 - A Foundation to Sleep On</a>提供了这个设计的背景和动机。<br>Boost.Chrono除了有标准库std::chrono的基本功能外，它还有很多其它功能，而且多了几个clock。</p>
<p>要使用chrono库，需要包含<code>#include&lt;chrono&gt;</code>，其所有实现均在std::chrono namespace中。这个库定义了三个主要类型：</p>
<ul>
<li><strong>Durations</strong> 用于测量时间跨度。像1分钟，2小时或者10毫秒。在这个库中，它们由<code>duration</code>类模板对象表示，它们由计数（count representation）和时间单位（period precision）组成，例如10毫秒由10（计数）和毫秒（时间单位）组成。</li>
<li><strong>Time points</strong> 代表一个特定的时间点，像某人的生日，下一趟火车的经过时间。在这个库中，<code>time_point</code>类模板的对象靠使用相对于标准时间点（epoch）的<code>duration</code>来表示特定时间点。</li>
<li><strong>Clocks</strong> 一个将时间点映射到真实物理时间的框架。一个时钟包含一个开始时间点（例如1970年1月1日）和计时周期（例如秒）。这个库提供了至少3个时钟，这些时钟提供了以<code>time_point</code>表示当前时间的方法。有<code>system_clock</code>, <code>steady_clock</code>和<code>high_resolution_clock</code>.</li>
</ul>
<h2 id="Durations"><a href="#Durations" class="headerlink" title="Durations"></a>Durations</h2><h3 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Rep, <span class="keyword">class</span> Period = ratio&lt;<span class="number">1</span>&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> duration;</span><br></pre></td></tr></table></figure>
<p><strong>Rep</strong>是一个算术类型，或者一个具有算法运算的类，用于表示计数。<br><strong>Period</strong>是一个ratio类型，表示以秒为单位的周期。</p>
<p>成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">count() <span class="comment">//返回计数，时间单位不一定是秒</span></span><br><span class="line">operators() <span class="comment">//各种算术运算</span></span><br></pre></td></tr></table></figure></p>
<p>一些有用的辅助类型：</p>
<table>
<thead>
<tr>
<th>type</th>
<th>Representation</th>
<th>Period</th>
</tr>
</thead>
<tbody>
<tr>
<td>hours</td>
<td>signed integral type of at least 23 bits</td>
<td>ratio<3600,1></3600,1></td>
</tr>
<tr>
<td>minutes</td>
<td>signed integral type of at least 29 bits</td>
<td>ratio<60,1></60,1></td>
</tr>
<tr>
<td>seconds</td>
<td>signed integral type of at least 35 bits</td>
<td>ratio<1,1></1,1></td>
</tr>
<tr>
<td>milliseconds</td>
<td>signed integral type of at least 45 bits</td>
<td>ratio<1,1000></1,1000></td>
</tr>
<tr>
<td>microseconds</td>
<td>signed integral type of at least 55 bits</td>
<td>ratio<1,1000000></1,1000000></td>
</tr>
<tr>
<td>nanoseconds</td>
<td>signed integral type of at least 64 bits</td>
<td>ratio<1,1000000000></1,1000000000></td>
</tr>
</tbody>
</table>
<p>这里说明一下<code>ratio</code>类型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">intmax_t</span> N, <span class="keyword">intmax_t</span> D = <span class="number">1</span>&gt; <span class="keyword">class</span> ratio;</span><br></pre></td></tr></table></figure></p>
<p>这个模板类能在编译时计算有理数。<br><strong>N</strong>是分子，<strong>D</strong>是分母，<code>ratio&lt;1,1000&gt;</code>表示单位时间是毫秒。</p>
<h2 id="Clocks"><a href="#Clocks" class="headerlink" title="Clocks"></a>Clocks</h2><h3 id="system_clock"><a href="#system_clock" class="headerlink" title="system_clock"></a>system_clock</h3><p>是一个系统时钟，有以下特性：</p>
<ul>
<li>真实时间<br>它被用于表示真实时间，因此它可以和time_t进行转换。</li>
<li>有符号的计数<br>它的<code>time_point</code>可以表示epoch前的时间（负值）。</li>
<li>系统级<br>运行在系统中的所有程序会得到同样的<code>time_point</code>值。</li>
</ul>
<p>成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">now() <span class="comment">//获取当前时间time_point</span></span><br><span class="line"><span class="keyword">to_time_t</span>() <span class="comment">//将time_point转换成time_t秒</span></span><br><span class="line"><span class="keyword">from_time_t</span>() <span class="comment">//将time_t转换成time_point</span></span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="built_in">std</span>::chrono::system_clock;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt; &gt; one_day (<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  system_clock::time_point today = system_clock::now();</span><br><span class="line">  system_clock::time_point tomorrow = today + one_day;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">time_t</span> tt;</span><br><span class="line"></span><br><span class="line">  tt = system_clock::<span class="keyword">to_time_t</span> ( today );</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today is: "</span> &lt;&lt; ctime(&amp;tt);</span><br><span class="line"></span><br><span class="line">  tt = system_clock::<span class="keyword">to_time_t</span> ( tomorrow );</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"tomorrow will be: "</span> &lt;&lt; ctime(&amp;tt);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="steady_clock"><a href="#steady_clock" class="headerlink" title="steady_clock"></a>steady_clock</h3><p>稳定时钟，表示一个单调递增时钟，它与系统时钟（wall clock time)无关，如果修改了系统时间，也不会影响到此时钟。适用于测量时间间隔，例如算法计时。</p>
<p>成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now() <span class="comment">//获取当前时间点</span></span><br></pre></td></tr></table></figure></p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"></span><br><span class="line">  steady_clock::time_point t1 = steady_clock::now();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"printing out 1000 stars...\n"</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i) <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"*"</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">  steady_clock::time_point t2 = steady_clock::now();</span><br><span class="line"></span><br><span class="line">  duration&lt;<span class="keyword">double</span>&gt; time_span = duration_cast&lt;duration&lt;<span class="keyword">double</span>&gt;&gt;(t2 - t1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"It took me "</span> &lt;&lt; time_span.count() &lt;&lt; <span class="string">" seconds."</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="high_resolution_clock"><a href="#high_resolution_clock" class="headerlink" title="high_resolution_clock"></a>high_resolution_clock</h3><p>高精度时钟，是一个拥有最短计时周期的时钟，是<code>system_clock</code>或者<code>steady_clock</code>的别名。</p>
<p>成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">now() <span class="comment">//获取当前时间点</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Time_points"><a href="#Time_points" class="headerlink" title="Time points"></a>Time points</h2><h3 id="time_point"><a href="#time_point" class="headerlink" title="time_point"></a>time_point</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration = <span class="keyword">typename</span> Clock::duration&gt;</span><br><span class="line">  <span class="keyword">class</span> time_point;</span><br></pre></td></tr></table></figure>
<p>是一个时间点，是从标准时间点（epoch，起始时间，一个时间参考点）开始的时间长度。内部存储了一个<code>duration</code>对象，并使用<code>Clock</code>作为标准时间点（epoch）的参考。</p>
<p>成员函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time_since_epoch() <span class="comment">//返回从它的epoch开始到当前时间点的duration时间（时间段）</span></span><br><span class="line">operators <span class="comment">//各种算式运算操作和关系运算操作</span></span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：两个<code>time_point</code>相减，得到<code>duration</code>类型。</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> now_c = <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(now - <span class="built_in">std</span>::chrono::hours(<span class="number">24</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"24 hours ago, the time was "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::put_time(<span class="built_in">std</span>::localtime(&amp;now_c), <span class="string">"%F %T"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point start = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::steady_clock::time_point end = <span class="built_in">std</span>::chrono::steady_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Printing took "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::microseconds&gt;(end - start).count()</span><br><span class="line">              &lt;&lt; <span class="string">"us.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5176_u5B83_u8F85_u52A9_u51FD_u6570"><a href="#u5176_u5B83_u8F85_u52A9_u51FD_u6570" class="headerlink" title="其它辅助函数"></a>其它辅助函数</h2><h3 id="time_point_cast"><a href="#time_point_cast" class="headerlink" title="time_point_cast"></a>time_point_cast</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ToDuration, <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration&gt;</span><br><span class="line">  time_point&lt;Clock,ToDuration&gt; time_point_cast (<span class="keyword">const</span> time_point&lt;Clock,Duration&gt;&amp; tp);</span><br></pre></td></tr></table></figure>
<p>转换time_point从一个<code>duration</code>到另一个<code>duration</code>。相当于转换了time_point的时间单位。<br><strong>注意</strong>：此函数的模板参数是<code>duration</code>类型，而不是<code>time_point</code>类型。</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ratio&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> duration&lt;<span class="keyword">int</span>,<span class="built_in">std</span>::ratio&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>&gt;&gt; days_type;</span><br><span class="line"></span><br><span class="line">  time_point&lt;system_clock,days_type&gt; today = time_point_cast&lt;days_type&gt;(system_clock::now());</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; today.time_since_epoch().count() &lt;&lt; <span class="string">" days since epoch"</span> &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">// 15490 days since epoch</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="duration_cast"><a href="#duration_cast" class="headerlink" title="duration_cast"></a>duration_cast</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> ToDuration, <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period&gt;</span><br><span class="line">  <span class="function"><span class="keyword">constexpr</span> ToDuration <span class="title">duration_cast</span> <span class="params">(<span class="keyword">const</span> duration&lt;Rep,Period&gt;&amp; dtn)</span></span>;</span><br></pre></td></tr></table></figure>
<p>功能与<code>time_point_cast</code>一样，只是作用的对象是<code>duration</code>类型。</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span>     // std::cout</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span>       // std::chrono::seconds, std::chrono::milliseconds</span></span><br><span class="line">                        <span class="comment">// std::chrono::duration_cast</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::chrono::<span class="function">seconds <span class="title">s</span> <span class="params">(<span class="number">1</span>)</span></span>;             <span class="comment">// 1 second</span></span><br><span class="line">  <span class="built_in">std</span>::chrono::milliseconds ms = <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::milliseconds&gt; (s);</span><br><span class="line"></span><br><span class="line">  ms += <span class="built_in">std</span>::chrono::milliseconds(<span class="number">2500</span>);  <span class="comment">// 2500 millisecond</span></span><br><span class="line"></span><br><span class="line">  s = <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::seconds&gt; (ms);   <span class="comment">// truncated</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ms: "</span> &lt;&lt; ms.count() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">//ms: 3500</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"s: "</span> &lt;&lt; s.count() &lt;&lt; <span class="built_in">std</span>::endl; <span class="comment">//s: 3</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u683C_u5F0F_u5316_u65F6_u95F4"><a href="#u683C_u5F0F_u5316_u65F6_u95F4" class="headerlink" title="格式化时间"></a>格式化时间</h2><h3 id="time_point_u683C_u5F0F_u5316"><a href="#time_point_u683C_u5F0F_u5316" class="headerlink" title="time_point格式化"></a><code>time_point</code>格式化</h3><p><code>time_point</code>不能直接输出到stream中，需要转换成<code>std::time_t</code>或者<code>std::tm</code>，使用<code>ctime</code>、<code>asctime</code>、<code>strftime</code>或者<code>std::put_time</code>格式化成字符串。</p>
<p>示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">system_clock::time_point today = system_clock::now();</span><br><span class="line"><span class="keyword">time_t</span> tt;</span><br><span class="line"></span><br><span class="line">tt = system_clock::<span class="keyword">to_time_t</span> ( today );</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today is: "</span> &lt;&lt; ctime(&amp;tt);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"today is: "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::put_time(<span class="built_in">std</span>::localtime(&amp;tt), <span class="string">"%F %T"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h2><ul>
<li><code>durationS</code>代表了一个时间段，即多少个时间单位。</li>
<li><code>time_pointS</code>代表了从一个时间参考点开始经历了多长时间，是一个时间点。例如，开机后3小时，从计时器开始后的3秒钟等等。其中时间参考点由<code>clockS</code>提供，时长由<code>duration</code>表示。当两个时间点拥有同样的时间参考点，就可以进行比较和计算。</li>
<li><code>clockS</code>代表一个现实时钟，由参考时间点和计时周期组成。可以自定义<code>clock</code>。<code>now()</code>函数返回当前时间点<code>time_point</code>。</li>
<li><code>clockS</code>和<code>time_pointS</code>之间紧密的相互联系和引用。</li>
</ul>
<p><img src="/images/chrono.png" alt="三者之间的关系和不同时钟的关系"></p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="http://en.cppreference.com" target="_blank" rel="external">cppreference.com</a></li>
<li><a href="http://www.cplusplus.com/" target="_blank" rel="external">cplusplus</a></li>
<li><a href="http://www.cnblogs.com/jwk000/p/3560086.html" target="_blank" rel="external">C++11 std::chrono库详解</a></li>
</ol>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2016/01/06/C++时间库（二）/">http://yoursite.com/2016/01/06/C++时间库（二）/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自从C++11之后，标准库中出现了一个std::chrono库，这个库对时间的一些感念进行抽象，在灵活性和扩展性上要好于C风格的时间函数。下面就梳理一下这个库。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[C++时间库（一） C风格的时间函数]]></title>
    <link href="http://yoursite.com/2016/01/06/C++%E6%97%B6%E9%97%B4%E5%BA%93%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2016/01/06/C++时间库（一）/</id>
    <published>2016-01-06T04:19:22.000Z</published>
    <updated>2016-01-07T07:06:29.312Z</updated>
    <content type="html"><![CDATA[<p>在C++开发时，经常会用到与时间相关的函数或者库，例如C风格的时间函数、std::chrono库、Boost.Date_Time库。<br>他们都包含哪些时间函数或者类？它们的设计思想是什么？什么情况选择什么样的时间函数？怎么使用呢？大家可能都会有这些方面的疑问，于是我决定就对这些库总结梳理一下。</p>
<p>由于文章太长，分成四部分：C风格的时间函数、std::chrono库、Boost.Date_Time库和总结。</p>
<a id="more"></a>
<p>C风格的时间类型和函数，有C和C++两个版本，如果使用C版本需要包含<code>#include &lt;time.h&gt;</code>，如果使用C++版本需要包含<code>#include &lt;ctime&gt;</code>，并且使用命名空间<code>std</code>。与平台相关的类型和函数会特别指出。</p>
<h2 id="u6570_u636E_u7C7B_u578B"><a href="#u6570_u636E_u7C7B_u578B" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="time_t"><a href="#time_t" class="headerlink" title="time_t"></a>time_t</h3><p>日历时间（calendar time）。在C/C++编程中经常会遇到它，它定义为从协调时间时（UTC）1970年01月01日00时00分00秒起至现在的总秒数，被用于表示Unix时间（戳）。<br>一般编译器使用32位整数表示time_t，因此这个时间最多使用到2038年1月18日19时14分07秒。一些编译器使用64位整数来表示time_t，可以避免这个问题。</p>
<h3 id="struct_tm"><a href="#struct_tm" class="headerlink" title="struct tm"></a>struct tm</h3><p>分解时间（broken-down time）。是一个存储了日期和时间的结构体，定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> tm</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> tm_sec;  <span class="comment">/*秒，正常范围0-59， 但允许至61, C99(C++11)改为60*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_min;  <span class="comment">/*分钟，0-59*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_hour; <span class="comment">/*小时， 0-23*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_mday; <span class="comment">/*日，即一个月中的第几天，1-31*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_mon;  <span class="comment">/*月， 从一月算起，0-11，1+tm_mon*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_year;  <span class="comment">/*年， 从1900至今已经多少年， 1900+tm_year*/</span>  </span><br><span class="line">    <span class="keyword">int</span> tm_wday; <span class="comment">/*星期，一周中的第几天， 从星期日算起，0-6*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_yday; <span class="comment">/*从今年1月1日到目前的天数，范围0-365，其中0代表1月1日，1代表1月2日，以此类推*/</span></span><br><span class="line">    <span class="keyword">int</span> tm_isdst; <span class="comment">/* 夏令时标识符，tm_isdst&gt;0，实行夏令时的时候；tm_isdst=0, 不实行夏令时的进候；tm_isdst&lt;0, 表示未知。*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要特别注意的是，年份是从1900年起至今多少年，而不是直接存储如2011年，月份从0开始的，0表示一月，星期也是从0开始的，0表示星期日，1表示星期一。</p>
<h3 id="clock_t"><a href="#clock_t" class="headerlink" title="clock_t"></a>clock_t</h3><p>时钟滴答数（clock tick）。记录从进程开始的时间，是一个相对时间，与<strong>CLOCKS_PER_SEC</strong>（每秒内时钟滴答数，定义在time.h中，一般为1000）相关。一般用32位整数表示clock_t。</p>
<h3 id="struct_timeval"><a href="#struct_timeval" class="headerlink" title="struct timeval"></a>struct timeval</h3><p>它表示一个时间间隔，这个类型不是标准的C++类型，而是定义在Berkeley Software Distribution (BSD)的Time.h中的一个类型，定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> timeval &#123;</span><br><span class="line">  <span class="keyword">long</span> tv_sec;   <span class="comment">//秒</span></span><br><span class="line">  <span class="keyword">long</span> tv_usec;  <span class="comment">//微秒</span></span><br><span class="line">&#125; timeval;</span><br></pre></td></tr></table></figure></p>
<p>这个类型具有更高的精度，但不具有跨平台性，主要在Unix或类Unix系统中使用，需要包含头文件<code>&lt;sys/time.h&gt;</code>，与<code>gettimeofday</code>函数配合使用。<br>在Windows下也定义了此结构，主要被Windows Sockets函数<code>select</code>使用，定义在头文件<code>Winsock2.h</code>中。<br>为了跨平台，尽量不要使用此类型。</p>
<h2 id="u83B7_u53D6_u65F6_u95F4_u51FD_u6570"><a href="#u83B7_u53D6_u65F6_u95F4_u51FD_u6570" class="headerlink" title="获取时间函数"></a>获取时间函数</h2><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> time (<span class="keyword">time_t</span>* timer);</span><br></pre></td></tr></table></figure>
<p>返回自从00:00 hours, Jan 1, 1970 UTC (i.e., the current unix timestamp)到现在的秒数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> timer;</span><br><span class="line">time(&amp;timer);  <span class="comment">/* get current time; same as: timer = time(NULL)  */</span></span><br></pre></td></tr></table></figure></p>
<h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clock_t</span> clock(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<p>得到从进程启动到此次函数调用的累计的时钟滴答数。可以用于算法计时。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">clock_t</span> start, finish;</span><br><span class="line">start = clock();</span><br><span class="line">...</span><br><span class="line">finish = clock();</span><br><span class="line">duration = (<span class="keyword">double</span>)(finish - start) / CLOCKS_PER_SEC;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"%2.1f seconds\n"</span>, duration );</span><br></pre></td></tr></table></figure></p>
<h3 id="GetLocalTime"><a href="#GetLocalTime" class="headerlink" title="GetLocalTime"></a>GetLocalTime</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">GetLocalTime</span><span class="params">(</span><br><span class="line">  _Out_ LPSYSTEMTIME lpSystemTime</span><br><span class="line">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _SYSTEMTIME &#123;</span><br><span class="line">  WORD wYear;          <span class="comment">//有效值是从1601年到30827年</span></span><br><span class="line">  WORD wMonth;         <span class="comment">//有效值是从1到12</span></span><br><span class="line">  WORD wDayOfWeek;     <span class="comment">//有效值是从0到6，0是周日</span></span><br><span class="line">  WORD wDay;           <span class="comment">//有效值是从1到31</span></span><br><span class="line">  WORD wHour;          <span class="comment">//有效值是从0到23</span></span><br><span class="line">  WORD wMinute;        <span class="comment">//有效值是从0到59</span></span><br><span class="line">  WORD wSecond;        <span class="comment">//有效值是从0到59</span></span><br><span class="line">  WORD wMilliseconds;  <span class="comment">//有效值是从0到999</span></span><br><span class="line">&#125; SYSTEMTIME, *PSYSTEMTIME;</span><br></pre></td></tr></table></figure>
<p>Windows函数，能获取当前日期和时间（UTC），能精确到毫秒，不具有跨平台性。<br>如果想获取更高精度的时间（&lt;1us），可以用<code>QueryPerformanceCounter</code>和<code>QueryPerformanceFrequency</code>。</p>
<h2 id="u65F6_u95F4_u65E5_u671F_u6570_u636E_u7C7B_u578B_u7684_u8F6C_u6362_u51FD_u6570"><a href="#u65F6_u95F4_u65E5_u671F_u6570_u636E_u7C7B_u578B_u7684_u8F6C_u6362_u51FD_u6570" class="headerlink" title="时间日期数据类型的转换函数"></a>时间日期数据类型的转换函数</h2><h3 id="gmtime__uFF08time_t_-_26gt_3B_tm_uFF09"><a href="#gmtime__uFF08time_t_-_26gt_3B_tm_uFF09" class="headerlink" title="gmtime （time_t -&gt; tm）"></a>gmtime （time_t -&gt; tm）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> tm * <span class="title">gmtime</span> <span class="params">(<span class="keyword">const</span> time_t * timer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>转换time_t成UTC时间的tm结构体。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line"><span class="keyword">struct</span> tm * ptm;</span><br><span class="line">time ( &amp;rawtime );</span><br><span class="line">ptm = gmtime ( &amp;rawtime );</span><br></pre></td></tr></table></figure></p>
<h3 id="localtime__uFF08time_t_-_26gt_3B_tm_uFF09"><a href="#localtime__uFF08time_t_-_26gt_3B_tm_uFF09" class="headerlink" title="localtime （time_t -&gt; tm）"></a>localtime （time_t -&gt; tm）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> tm * <span class="title">localtime</span> <span class="params">(<span class="keyword">const</span> time_t * timer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>转换time_t成本地时区的tm结构体。<br>多个线程同时调用<strong>localtime</strong>会引起数据竞争，下面的<a href="#thread">线程安全</a>部分会讲到它，也可以参看<a href="/2016/01/06/localtime的安全性总结">localtime的安全性总结</a>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> rawtime;</span><br><span class="line"><span class="keyword">struct</span> tm * timeinfo;</span><br><span class="line"></span><br><span class="line">time (&amp;rawtime);</span><br><span class="line">timeinfo = localtime (&amp;rawtime);</span><br><span class="line"><span class="built_in">printf</span> (<span class="string">"Current local time and date: %s"</span>, asctime(timeinfo));</span><br></pre></td></tr></table></figure></p>
<h3 id="mktime__uFF08tm_-_26gt_3B_time_t_uFF09"><a href="#mktime__uFF08tm_-_26gt_3B_time_t_uFF09" class="headerlink" title="mktime （tm -&gt; time_t）"></a>mktime （tm -&gt; time_t）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">time_t</span> mktime (<span class="keyword">struct</span> tm * timeptr);</span><br></pre></td></tr></table></figure>
<p>转换本地时间的tm结构体成time_t。<br>这个函数是<strong>localtime</strong>的逆操作。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> t = <span class="built_in">std</span>::time(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">std</span>::tm tm = *<span class="built_in">std</span>::localtime(&amp;t);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Today is           "</span> &lt;&lt; <span class="built_in">std</span>::put_time(&amp;tm, <span class="string">"%c %Z"</span>) &lt;&lt;<span class="string">'\n'</span>;</span><br><span class="line">    tm.tm_mon -= <span class="number">100</span>;  <span class="comment">// tm_mon is now outside its normal range</span></span><br><span class="line">    <span class="built_in">std</span>::mktime(&amp;tm);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"100 months ago was "</span> &lt;&lt; <span class="built_in">std</span>::put_time(&amp;tm, <span class="string">"%c %Z"</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Today is           Wed Dec <span class="number">28</span> <span class="number">09</span>:<span class="number">56</span>:<span class="number">10</span> <span class="number">2011</span> EST</span><br><span class="line"><span class="number">100</span> months ago was Thu Aug <span class="number">28</span> <span class="number">10</span>:<span class="number">56</span>:<span class="number">10</span> <span class="number">2003</span> EDT</span><br></pre></td></tr></table></figure></p>
<h2 id="u83B7_u53D6_u65F6_u95F4_u51FD_u6570_u4E0E_u65F6_u533A_u5173_u7CFB"><a href="#u83B7_u53D6_u65F6_u95F4_u51FD_u6570_u4E0E_u65F6_u533A_u5173_u7CFB" class="headerlink" title="获取时间函数与时区关系"></a>获取时间函数与时区关系</h2><p><img src="/images/time_zone.png" alt="enter description here"><br>关于时区的总结，请看<a href="/2016/01/04/时区和Unix时间戳的整理">时区和Unix时间戳的整理</a></p>
<h2 id="u65F6_u95F4_u65E5_u671F_u6570_u636E_u7684_u683C_u5F0F_u5316_u51FD_u6570"><a href="#u65F6_u95F4_u65E5_u671F_u6570_u636E_u7684_u683C_u5F0F_u5316_u51FD_u6570" class="headerlink" title="时间日期数据的格式化函数"></a>时间日期数据的格式化函数</h2><h3 id="ctime__uFF08time_t_-_26gt_3B_char*_uFF09"><a href="#ctime__uFF08time_t_-_26gt_3B_char*_uFF09" class="headerlink" title="ctime （time_t -&gt; char*）"></a><a name="ctime">ctime （time_t -&gt; char*）</a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">ctime</span> <span class="params">(<span class="keyword">const</span> time_t * timer)</span></span>;</span><br></pre></td></tr></table></figure>
<p>转换time_t成人类可读的字符串，是本地时间。<br>这个函数等价：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asctime(localtime(timer))</span><br></pre></td></tr></table></figure></p>
<p>格式如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Www Mmm dd hh:mm:ss yyyy</span><br></pre></td></tr></table></figure></p>
<p>Www是周几，Mmm是月份（字母表示），dd是当月的一天，hh::mm::ss是时间，yyyy是年份<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      /* printf */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>       /* time_t, time, ctime */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">time_t</span> rawtime;</span><br><span class="line"></span><br><span class="line">  time (&amp;rawtime);</span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"The current local time is: %s"</span>, ctime (&amp;rawtime));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="asctime__uFF08tm_-_26gt_3B_char*_uFF09"><a href="#asctime__uFF08tm_-_26gt_3B_char*_uFF09" class="headerlink" title="asctime （tm -&gt; char*）"></a>asctime （tm -&gt; char*）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">asctime</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm * timeptr)</span></span>;</span><br></pre></td></tr></table></figure>
<p>转换tm结构体成字符串。<br>这个函数等价：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">asctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *timeptr)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> wday_name[][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="string">"Sun"</span>, <span class="string">"Mon"</span>, <span class="string">"Tue"</span>, <span class="string">"Wed"</span>, <span class="string">"Thu"</span>, <span class="string">"Fri"</span>, <span class="string">"Sat"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> mon_name[][<span class="number">4</span>] = &#123;</span><br><span class="line">    <span class="string">"Jan"</span>, <span class="string">"Feb"</span>, <span class="string">"Mar"</span>, <span class="string">"Apr"</span>, <span class="string">"May"</span>, <span class="string">"Jun"</span>,</span><br><span class="line">    <span class="string">"Jul"</span>, <span class="string">"Aug"</span>, <span class="string">"Sep"</span>, <span class="string">"Oct"</span>, <span class="string">"Nov"</span>, <span class="string">"Dec"</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">char</span> result[<span class="number">26</span>];</span><br><span class="line">  <span class="built_in">sprintf</span>(result, <span class="string">"%.3s %.3s%3d %.2d:%.2d:%.2d %d\n"</span>,</span><br><span class="line">    wday_name[timeptr-&gt;tm_wday],</span><br><span class="line">    mon_name[timeptr-&gt;tm_mon],</span><br><span class="line">    timeptr-&gt;tm_mday, timeptr-&gt;tm_hour,</span><br><span class="line">    timeptr-&gt;tm_min, timeptr-&gt;tm_sec,</span><br><span class="line">    <span class="number">1900</span> + timeptr-&gt;tm_year);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>字符串格式同<a href="#ctime">ctime</a>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      /* printf */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>       /* time_t, struct tm, time, localtime, asctime */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">time_t</span> rawtime;</span><br><span class="line">  <span class="keyword">struct</span> tm * timeinfo;</span><br><span class="line"></span><br><span class="line">  time ( &amp;rawtime );</span><br><span class="line">  timeinfo = localtime ( &amp;rawtime );</span><br><span class="line">  <span class="built_in">printf</span> ( <span class="string">"The current date/time is: %s"</span>, asctime (timeinfo) );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="strftime__uFF08tm_-_26gt_3B_char*_uFF09"><a href="#strftime__uFF08tm_-_26gt_3B_char*_uFF09" class="headerlink" title="strftime （tm -&gt; char*）"></a>strftime （tm -&gt; char*）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> strftime (<span class="keyword">char</span>* ptr, <span class="keyword">size_t</span> maxsize, <span class="keyword">const</span> <span class="keyword">char</span>* format,</span><br><span class="line">                 <span class="keyword">const</span> <span class="keyword">struct</span> tm* timeptr );</span><br></pre></td></tr></table></figure>
<p>转换结构体tm为自定义格式的字符串，类似于<code>sprintf</code>。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      /* puts */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>       /* time_t, struct tm, time, localtime, strftime */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">time_t</span> rawtime;</span><br><span class="line">  <span class="keyword">struct</span> tm * timeinfo;</span><br><span class="line">  <span class="keyword">char</span> buffer [<span class="number">80</span>];</span><br><span class="line"></span><br><span class="line">  time (&amp;rawtime);</span><br><span class="line">  timeinfo = localtime (&amp;rawtime);</span><br><span class="line"></span><br><span class="line">  strftime (buffer,<span class="number">80</span>,<span class="string">"Now it's %I:%M%p."</span>,timeinfo);</span><br><span class="line">  <span class="built_in">puts</span> (buffer);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="strptime__uFF08char*_-_26gt_3B_tm_uFF09"><a href="#strptime__uFF08char*_-_26gt_3B_tm_uFF09" class="headerlink" title="strptime （char* -&gt; tm）"></a>strptime （char* -&gt; tm）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">strptime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* buf, <span class="keyword">const</span> <span class="keyword">char</span>* format, <span class="keyword">struct</span> tm* tptr)</span></span></span><br></pre></td></tr></table></figure>
<p><code>strftime</code>逆操作，把字符串按照自定义的格式转换为tm。</p>
<h3 id="std_3A_3Aput_time"><a href="#std_3A_3Aput_time" class="headerlink" title="std::put_time"></a>std::put_time</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> CharT &gt;</span><br><span class="line"><span class="comment">/*unspecified*/</span> put_time( <span class="keyword">const</span> <span class="built_in">std</span>::tm* tmb, <span class="keyword">const</span> CharT* fmt );</span><br></pre></td></tr></table></figure>
<p>转换结构体tm为自定义格式的字符串，类似于<code>strftime</code>，使用上比<code>strftime</code>方便，可以直接输出到stream中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::put_time(ptm,<span class="string">"%c"</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure></p>
<h2 id="u5BF9_u65F6_u95F4_u6570_u636E_u7684_u64CD_u4F5C"><a href="#u5BF9_u65F6_u95F4_u6570_u636E_u7684_u64CD_u4F5C" class="headerlink" title="对时间数据的操作"></a>对时间数据的操作</h2><h3 id="difftime"><a href="#difftime" class="headerlink" title="difftime"></a>difftime</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">difftime</span> <span class="params">(time_t end, time_t beginning)</span></span>;</span><br></pre></td></tr></table></figure>
<p>计算两个时间的差值，单位为秒。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span>      /* printf */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span>       /* time_t, struct tm, difftime, time, mktime */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="keyword">time_t</span> now;</span><br><span class="line">  <span class="keyword">struct</span> tm newyear;</span><br><span class="line">  <span class="keyword">double</span> seconds;</span><br><span class="line"></span><br><span class="line">  time(&amp;now);  <span class="comment">/* get current time; same as: now = time(NULL)  */</span></span><br><span class="line"></span><br><span class="line">  newyear = *localtime(&amp;now);</span><br><span class="line"></span><br><span class="line">  newyear.tm_hour = <span class="number">0</span>; newyear.tm_min = <span class="number">0</span>; newyear.tm_sec = <span class="number">0</span>;</span><br><span class="line">  newyear.tm_mon = <span class="number">0</span>;  newyear.tm_mday = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  seconds = difftime(now,mktime(&amp;newyear));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span> (<span class="string">"%.f seconds since new year in the current timezone.\n"</span>, seconds);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="u7EBF_u7A0B_u5B89_u5168"><a href="#u7EBF_u7A0B_u5B89_u5168" class="headerlink" title="线程安全"></a><a name="thread">线程安全</a></h2><h3 id="ctime_u548Casctime"><a href="#ctime_u548Casctime" class="headerlink" title="ctime和asctime"></a>ctime和asctime</h3><p><strong>ctime</strong>和<strong>asctime</strong>不是线程安全的，原因是返回的字符串指针指向了一个静态分配的字符串，会被后续函数调用复写掉。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** asctime returns a static allocated string shared with other calls</span><br><span class="line">* to asctime or ctime. Every time these functions are called the content</span><br><span class="line">* of the static string is overwritten*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">time_t</span> t1 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">std</span>::tm* t1_tm = <span class="built_in">std</span>::localtime(&amp;t1);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* t1_as_text = <span class="built_in">std</span>::asctime(t1_tm); <span class="comment">// save as dangerous string</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (original)   : "</span> &lt;&lt; t1_as_text &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">time_t</span> t2 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">  <span class="built_in">std</span>::tm* t2_tm = <span class="built_in">std</span>::localtime(&amp;t2);</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* t2_as_text = <span class="built_in">std</span>::asctime(t2_tm);  <span class="comment">// overwrite t1_as_text</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (overwritten): "</span> &lt;&lt; t1_as_text;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2              : "</span> &lt;&lt; t2_as_text &lt;&lt; <span class="built_in">std</span>::endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 (original) : Mon Jan <span class="number">21</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">30</span> <span class="number">2013</span></span><br><span class="line"></span><br><span class="line">t1 (overwrite): Mon Jan <span class="number">21</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">35</span> <span class="number">2013</span></span><br><span class="line">t2            : Mon Jan <span class="number">21</span> <span class="number">13</span>:<span class="number">56</span>:<span class="number">35</span> <span class="number">2013</span></span><br></pre></td></tr></table></figure></p>
<p>在Linux系统下，可以使用<code>ctime_r</code>和<code>asctime_r</code>这两个线程安全的函数，它们线程安全的原因是使用了用户自己分配的buffer，这个buffer至少有26字节的空间。<br>在Windows系统下，可以使用<code>ctime_s</code>和<code>asctime_s</code>这两个函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">asctime_r</span><span class="params">(<span class="keyword">const</span> <span class="keyword">struct</span> tm *tm, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">errno_t</span> ctime_s(</span><br><span class="line">   <span class="keyword">char</span>* buffer,</span><br><span class="line">   <span class="keyword">size_t</span> numberOfElements,</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">time_t</span> *time</span><br><span class="line">);</span><br><span class="line"><span class="keyword">errno_t</span> asctime_s(</span><br><span class="line">   <span class="keyword">char</span>* buffer,</span><br><span class="line">   <span class="keyword">size_t</span> numberOfElements,</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">struct</span> tm *_tm</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<h3 id="localtime_u548Cgmtime"><a href="#localtime_u548Cgmtime" class="headerlink" title="localtime和gmtime"></a>localtime和gmtime</h3><p><strong>localtime</strong>和<strong>gmtime</strong>也不是线程安全的。原因是，返回的std::tm指针在内部指向了静态的std::tm结构。<br>在Linux系统下，可以使用<code>localtime_r</code>和<code>gmtime_r</code>这两个线程安全的函数。<br>在Windows系统下，可以使用<code>localtime_s</code>和<code>gmtime_s</code>这两个函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">gmtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">errno_t</span> localtime_s(</span><br><span class="line">   <span class="keyword">struct</span> tm* _tm,</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">time_t</span> *time</span><br><span class="line">);</span><br><span class="line"><span class="keyword">errno_t</span> gmtime_s(</span><br><span class="line">   <span class="keyword">struct</span> tm* _tm,</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">__time_t</span>* time</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>为了跨平台并且多线程使用这些功能，下面定义安全的版本<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> g2&#123;</span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::chrono::time_point&lt;<span class="built_in">std</span>::chrono::system_clock&gt;  system_time_point;</span><br><span class="line"></span><br><span class="line"><span class="function">tm <span class="title">localtime</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::time_t&amp; time)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::tm tm_snapshot;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> (defined(WIN32) || defined(_WIN32) || defined(__WIN32__))</span></span><br><span class="line">  localtime_s(&amp;tm_snapshot, &amp;time);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">  localtime_r(&amp;time, &amp;tm_snapshot); <span class="comment">// POSIX</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="keyword">return</span> tm_snapshot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// To simplify things the return value is just a string. I.e. by design!</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">put_time</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::tm* date_time, <span class="keyword">const</span> <span class="keyword">char</span>* c_time_format)</span></span><br><span class="line"></span>&#123;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> (defined(WIN32) || defined(_WIN32) || defined(__WIN32__))</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">ostringstream</span> oss;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// BOGUS hack done for VS2012: C++11 non-conformant since it SHOULD take a "const struct tm*  "</span></span><br><span class="line">  <span class="comment">// ref. C++11 standard: ISO/IEC 14882:2011, § 27.7.1,</span></span><br><span class="line">  oss &lt;&lt; <span class="built_in">std</span>::put_time(<span class="keyword">const_cast</span>&lt;<span class="built_in">std</span>::tm*&gt;(date_time), c_time_format);</span><br><span class="line">  <span class="keyword">return</span> oss.str();</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span>    <span class="comment">// LINUX</span></span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">size_t</span> size = <span class="number">1024</span>;</span><br><span class="line">  <span class="keyword">char</span> buffer[size];</span><br><span class="line">  <span class="keyword">auto</span> success = <span class="built_in">std</span>::strftime(buffer, size, c_time_format, date_time);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span> == success)</span><br><span class="line">    <span class="keyword">return</span> c_time_format;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> buffer;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// extracting std::time_t from std:chrono for "now"</span></span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">time_t</span> systemtime_now()</span><br><span class="line">&#123;</span><br><span class="line">  system_time_point system_now = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::chrono::system_clock::<span class="keyword">to_time_t</span>(system_now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">// g2-namespace</span></span><br></pre></td></tr></table></figure></p>
<h2 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a href="https://zh.wikipedia.org/wiki/Time.h" target="_blank" rel="external">维基百科time.h</a></li>
<li><a href="http://en.cppreference.com" target="_blank" rel="external">cppreference.com</a></li>
<li><a href="http://www.cplusplus.com/" target="_blank" rel="external">cplusplus</a></li>
<li><a href="http://blog.csdn.net/love_gaohz/article/details/6637625" target="_blank" rel="external">c++ 时间类型详解 time_t</a></li>
<li><a href="https://kjellkod.wordpress.com/2013/01/22/exploring-c11-part-2-localtime-and-time-again/" target="_blank" rel="external">Exploring C++11, part 2 (localtime and time again)</a></li>
<li><a href="http://rabbit.eng.miami.edu/info/functions/time.html" target="_blank" rel="external">Unix, C, and C++Function Reference Time</a></li>
</ol>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2016/01/06/C++时间库（一）/">http://yoursite.com/2016/01/06/C++时间库（一）/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在C++开发时，经常会用到与时间相关的函数或者库，例如C风格的时间函数、std::chrono库、Boost.Date_Time库。<br>他们都包含哪些时间函数或者类？它们的设计思想是什么？什么情况选择什么样的时间函数？怎么使用呢？大家可能都会有这些方面的疑问，于是我决定就对这些库总结梳理一下。</p>
<p>由于文章太长，分成四部分：C风格的时间函数、std::chrono库、Boost.Date_Time库和总结。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[localtime的安全性总结]]></title>
    <link href="http://yoursite.com/2016/01/06/localtime%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2016/01/06/localtime的安全性总结/</id>
    <published>2016-01-06T02:15:10.000Z</published>
    <updated>2016-01-07T07:12:51.949Z</updated>
    <content type="html"><![CDATA[<p> <code>std::localtime</code>这个函数功能是将time_t转换成本地时间的结构体tm。功能同C风格的函数<code>localtime</code>，只是不带命名空间。<br> 按照标准说法此函数不是线程安全的。</p>
 <a id="more"></a>
<p>见cplusplus上提示</p>
<blockquote>
<p>The function also accesses and modifies a shared internal object, which may introduce data races on concurrent calls to gmtime and localtime.</p>
</blockquote>
<p>cpprefence上说得更明确</p>
<blockquote>
<p>This function may not be thread-safe.</p>
</blockquote>
<p>但在不同平台下实现还是不一样的。</p>
<h2 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h2><p>在Windows下，此函数是线程安全的。</p>
<blockquote>
<p>Both the 32-bit and 64-bit versions of gmtime, mktime, mkgmtime, and localtime all use a single tm structure per thread for the conversion. </p>
</blockquote>
<p>意思是，不管是32位还是64位版本，这个函数都会为每一个线程分配一个单独的tm结构体。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">time_t</span> t1 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::tm*  t1_tm = <span class="built_in">std</span>::localtime(&amp;t1);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (original)   :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t1_tm) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">	<span class="built_in">std</span>::<span class="function">thread <span class="title">thread1</span><span class="params">(<span class="built_in">std</span>::bind([&amp;t1_tm]()</span></span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="keyword">time_t</span> t2 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">		<span class="built_in">std</span>::tm*  t2_tm = <span class="built_in">std</span>::localtime(&amp;t2);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1              :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t1_tm);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2              :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t2_tm);</span><br><span class="line">	&#125;));</span><br><span class="line">	thread1.join();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 (original)   :Fri Dec <span class="number">04</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">11</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">t1              :Fri Dec <span class="number">04</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">11</span> <span class="number">2015</span></span><br><span class="line">t2              :Fri Dec <span class="number">04</span> <span class="number">11</span>:<span class="number">26</span>:<span class="number">16</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<p>在主线程中调用<code>localtime</code>，打印的时间t1与在另一个线程中打印的时间t1是相同的，可见，Windows下的<code>localtime</code>是线程安全的。</p>
<h2 id="POSIX"><a href="#POSIX" class="headerlink" title="POSIX"></a>POSIX</h2><p>此时函数就不是线程安全的。不是线程安全的原因是，这个函数内部使用了一个静态tm结构体，每个访问它的函数都会修改这个值。</p>
<p>与上面同样的代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="keyword">time_t</span> t1 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">    <span class="built_in">std</span>::tm*  t1_tm = <span class="built_in">std</span>::localtime(&amp;t1);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (original)   :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t1_tm) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">thread1</span><span class="params">(<span class="built_in">std</span>::bind([&amp;t1_tm]()</span></span>&#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="keyword">time_t</span> t2 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">		<span class="built_in">std</span>::tm*  t2_tm = <span class="built_in">std</span>::localtime(&amp;t2);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (overwritten):"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t1_tm);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2              :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t2_tm);</span><br><span class="line">            &#125;));</span><br><span class="line">    thread1.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译选项<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -std=c++<span class="number">11</span> -pthread localtimetest.cpp -o localtimetest</span><br></pre></td></tr></table></figure></p>
<p>结果是<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 (original)   :Fri Dec  <span class="number">4</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">40</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">t1 (overwritten):Fri Dec  <span class="number">4</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">45</span> <span class="number">2015</span></span><br><span class="line">t2              :Fri Dec  <span class="number">4</span> <span class="number">11</span>:<span class="number">30</span>:<span class="number">45</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<p>另一个线程打印的时间t1与主线程中打印的时间t1不同，而与这个线程下的t2相同，说明这个线程中调用的<code>localtime</code>修改了主线程中调用<code>localtime</code>的结果。所以不是线程安全的。</p>
<h2 id="u6CE8_u610F"><a href="#u6CE8_u610F" class="headerlink" title="注意"></a>注意</h2><p>虽然Window下的<code>localtime</code>是线程安全的，但是要注意在调用<code>localtime</code>后，不要再使用前一个调用<code>localtime</code>的结果，MSDN上说明：</p>
<blockquote>
<p>Each call to one of these routines destroys the result of the previous call.</p>
</blockquote>
<p>意思是每次调用这个函数都会破坏前一个调用的结果。</p>
<p>看示例：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">time_t</span> t1 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">	<span class="built_in">std</span>::<span class="keyword">time_t</span> t2 = <span class="built_in">std</span>::time(<span class="literal">nullptr</span>);</span><br><span class="line">	<span class="comment">// std::tm* points to static data that will be overwritten</span></span><br><span class="line">	<span class="comment">// for any new localtime call</span></span><br><span class="line">	<span class="comment">// 1) Print the original value before it is overwritten  </span></span><br><span class="line">	<span class="built_in">std</span>::tm*  t1_tm = localtime(&amp;t1);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (original)   :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t1_tm) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2) Print t2 and t1 after t1 is overwritten by t2</span></span><br><span class="line">	<span class="built_in">std</span>::tm*  t2_tm = localtime(&amp;t2);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t1 (overwritten):"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t1_tm);</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"t2              :"</span> &lt;&lt; <span class="built_in">std</span>::asctime(t2_tm);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果：<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1 (original)   :Fri Dec <span class="number">04</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">34</span> <span class="number">2015</span></span><br><span class="line"></span><br><span class="line">t1 (overwritten):Fri Dec <span class="number">04</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">39</span> <span class="number">2015</span></span><br><span class="line">t2              :Fri Dec <span class="number">04</span> <span class="number">11</span>:<span class="number">39</span>:<span class="number">39</span> <span class="number">2015</span></span><br></pre></td></tr></table></figure></p>
<p>这个程序在第二次调用<code>localtime</code>之后，就把第一次调用<code>localtime</code>的结果<code>t1_tm</code>覆盖了。这个错误会非常隐蔽的发生，要特别注意。当然可以使用<code>localtime_s</code>（Windows）或者<code>localtime_r</code>（POSIX）来避免。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">struct</span> tm *<span class="title">localtime_r</span><span class="params">(<span class="keyword">const</span> time_t *timep, <span class="keyword">struct</span> tm *result)</span></span>;</span><br><span class="line"><span class="keyword">errno_t</span> localtime_s( <span class="keyword">struct</span> tm* _tm, <span class="keyword">const</span> <span class="keyword">time_t</span> *time );</span><br></pre></td></tr></table></figure></p>
<p>原因就是，这两个函数会返回自定义的tm结构体。</p>
<p><strong>声明</strong>：以上代码参考<a href="https://kjellkod.wordpress.com/2013/01/22/exploring-c11-part-2-localtime-and-time-again/" target="_blank" rel="external">Exploring C++11, part 2 (localtime and time again)</a></p>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2016/01/06/localtime的安全性总结/">http://yoursite.com/2016/01/06/localtime的安全性总结/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p> <code>std::localtime</code>这个函数功能是将time_t转换成本地时间的结构体tm。功能同C风格的函数<code>localtime</code>，只是不带命名空间。<br> 按照标准说法此函数不是线程安全的。</p>]]>
    
    </summary>
    
      <category term="C++" scheme="http://yoursite.com/tags/C/"/>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[时区和Unix时间戳的整理]]></title>
    <link href="http://yoursite.com/2016/01/04/%E6%97%B6%E5%8C%BA%E5%92%8CUnix%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2016/01/04/时区和Unix时间戳的整理/</id>
    <published>2016-01-03T16:00:00.000Z</published>
    <updated>2016-01-07T07:05:41.449Z</updated>
    <content type="html"><![CDATA[<p>对时区和Unix时间戳的简单总结整理。</p>
<a id="more"></a>
<h2 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h2><p>Coordinated Universal Time，协调世界时，又称世界标准时间或世界协调时间，是最主要的世界时间标准，其以原子时秒长为基础，在时刻上尽量接近于格林尼治标准时间。<br>中国大陆时间比UTC快8小时，就会写作UTC+8，俗称东8区。<br>参考维基百科<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E8%B0%83%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="external">协调世界时</a></p>
<h2 id="GMT"><a href="#GMT" class="headerlink" title="GMT"></a>GMT</h2><p>Greenwich Mean Time，格林尼治标准时间（中国大陆翻译：格林尼治平均时间或格林尼治标准时间），是指位于英国伦敦郊区的皇家格林尼治天文台的标准时间，因为本初子午线被定义为通过那里的经线。</p>
<p>理论上来说，格林尼治标准时间的正午是指当太阳横穿格林尼治子午线时（也就是在格林尼治上空最高点时）的时间。由于地球在它的椭圆轨道里的运动速度不均匀，这个时刻可能与实际的太阳时有误差，最大误差达16分钟。</p>
<p>由于地球每天的自转是有些不规则的，而且正在缓慢减速，因此格林尼治时间已经不再被作为标准时间使用。现在的标准时间，是由原子钟报时的协调世界时（UTC）。<br>参考维基百科<a href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%9E%97%E5%B0%BC%E6%B2%BB%E5%B9%B3%E6%97%B6" target="_blank" rel="external">格林尼治标准时间</a></p>
<h2 id="CST"><a href="#CST" class="headerlink" title="CST"></a>CST</h2><p>China Standard Time，中国标准时间，又称北京时间。是中国大陆的标准时间，比世界协调时快八小时（即UTC+8），与香港、澳门、台湾、马来西亚、新加坡等地的标准时间相同。<br>参考维基百科<a href="https://zh.wikipedia.org/wiki/%E5%8C%97%E4%BA%AC%E6%97%B6%E9%97%B4" target="_blank" rel="external">北京时间</a></p>
<h2 id="UT"><a href="#UT" class="headerlink" title="UT"></a>UT</h2><p>Universal Time，是一种以格林尼治子夜起算的平太阳时。世界时是以地球自转为基准得到的时间尺度,其精度受到地球自转不均匀变化和极移的影响，为了解决这种影响，1955年国际天文联合会定义了UT0、UT1和UT2三个系统：</p>
<p>UT0系统是由天文观测直接测定的世界时，未经任何改正。该系统曾长期被认为是稳定均匀的时间计量系统，得到过广泛应用，又叫做格林尼治平均时间（GMT）。<br>UT1系统是在UT0的基础上加入了极移改正 Δλ，修正地轴摆动的影响。<br>UT2系统是在UT1基础上加入了地球自转速率的季节性改正 ΔT</p>
<p>参考维基百科<a href="https://zh.wikipedia.org/wiki/%E4%B8%96%E7%95%8C%E6%97%B6" target="_blank" rel="external">世界时</a></p>
<h2 id="CET"><a href="#CET" class="headerlink" title="CET"></a>CET</h2><p>Central European Time，欧洲中部时间，是比世界标准时间（UTC）早一个小时的时区名称之一。它被大部分欧洲国家和部分北非国家采用。</p>
<h2 id="Unix_timestamp"><a href="#Unix_timestamp" class="headerlink" title="Unix timestamp"></a>Unix timestamp</h2><p>Unix时间戳，或称Unix时间， POSIX时间是一种时间表示方式，定义为从格林威治时间1970年01月01日00时00分00秒起至现在的总秒数。Unix时间戳不仅被使用在Unix系统、类Unix系统中，也在许多其他操作系统中被广泛采用。<br>目前相当一部分操作系统使用32位二进制数字表示时间。此类系统的Unix时间戳最多可以使用到格林威治时间2038年01月19日03时14分07秒（二进制：01111111 11111111 11111111 11111111）。其后一秒，二进制数字会变为10000000 00000000 00000000 00000000，发生溢出错误，造成系统将时间误解为1901年12月13日20时45分52秒。这很可能会引起软件故障，甚至是系统瘫痪。使用64位二进制数字表示时间的系统（最多可以使用到格林威治时间292,277,026,596年12月04日15时30分08秒）则基本不会遇到这类溢出问题。</p>
<p>参考<a href="http://blog.csdn.net/love_gaohz/article/details/6637625" target="_blank" rel="external">c++ 时间类型详解 time_t</a></p>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2016/01/04/时区和Unix时间戳的整理/">http://yoursite.com/2016/01/04/时区和Unix时间戳的整理/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对时区和Unix时间戳的简单总结整理。</p>]]>
    
    </summary>
    
      <category term="整理" scheme="http://yoursite.com/categories/%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[终于开张了]]></title>
    <link href="http://yoursite.com/2015/12/25/%E5%BC%80%E5%BC%A0/"/>
    <id>http://yoursite.com/2015/12/25/开张/</id>
    <published>2015-12-24T16:00:00.000Z</published>
    <updated>2016-01-07T07:02:18.405Z</updated>
    <content type="html"><![CDATA[<p>在酝酿（实际拖延）了接近一年之后，<br>在2015年末，<br>在西方圣诞节这一天，<br>终于鼓足勇气搭建起了自己的博客。</p>
<a id="more"></a>
<p>完成了自己的年度计划，<br>开启了自己的写作之路。</p>
<p>希望她能作为督促我思考的动力，<br>知识升华的工具，<br>交流的平台，<br>展示的舞台。</p>
<p>今天迈开了艰难的第一步，<br>希望今后能一直相伴走下去。<br>祝我们好运！</p>
<hr>
<p><strong>版权声明</strong></p>
<p>本博客 <a href="http://oabinga.github.io/" target="_blank" rel="external">思</a> 采用<a href="http://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议进行许可</a></p>
<p>本文永久链接：<a href="http://yoursite.com/2015/12/25/开张/">http://yoursite.com/2015/12/25/开张/</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在酝酿（实际拖延）了接近一年之后，<br>在2015年末，<br>在西方圣诞节这一天，<br>终于鼓足勇气搭建起了自己的博客。</p>]]>
    
    </summary>
    
      <category term="随笔" scheme="http://yoursite.com/categories/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
</feed>
